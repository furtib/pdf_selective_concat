<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro PDF Stitcher v2</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css">

    <style>
        :root {
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --bg: #f8fafc;
            --panel-bg: #ffffff;
            --border: #e2e8f0;
            --viewer-bg: #525659;
            --text-main: #334155;
        }

        body { margin: 0; font-family: 'Inter', system-ui, sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; background: var(--bg); color: var(--text-main); }

        /* --- Header & Tabs --- */
        header { background: var(--panel-bg); border-bottom: 1px solid var(--border); display: flex; flex-direction: column; z-index: 20; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .top-bar { padding: 8px 12px; display: flex; align-items: center; gap: 15px; height: 40px; }
        .logo { font-weight: 800; color: var(--primary); font-size: 1.1rem; letter-spacing: -0.5px; margin-right: 10px; }

        .tabs-track { flex: 1; overflow-x: auto; display: flex; gap: 6px; padding-bottom: 2px; scrollbar-width: none; }
        .tabs-track::-webkit-scrollbar { display: none; }

        .doc-tab {
            background: #f1f5f9; border: 1px solid #cbd5e1; padding: 6px 12px; border-radius: 6px;
            font-size: 13px; display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;
            transition: all 0.2s; max-width: 200px;
        }
        .doc-tab:hover { background: #e2e8f0; }
        .doc-tab.active { background: var(--primary); color: white; border-color: var(--primary-dark); }
        .doc-tab span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .close-tab { opacity: 0.6; font-size: 14px; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 50%; }
        .close-tab:hover { background: rgba(0,0,0,0.2); opacity: 1; }

        .btn { padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border); background: white; cursor: pointer; font-size: 13px; font-weight: 500; transition: 0.1s; }
        .btn:hover { background: #f8fafc; border-color: #cbd5e1; }
        .btn-primary { background: var(--primary); color: white; border: none; }
        .btn-primary:hover { background: var(--primary-dark); }
        .btn.active { background: #fee2e2; color: #b91c1c; border-color: #fca5a5; }

        .toolbar { padding: 8px 15px; border-top: 1px solid var(--border); display: flex; gap: 15px; align-items: center; background: white; font-size: 13px; }

        /* --- Layout --- */
        .workspace { flex: 1; display: flex; overflow: hidden; }

        /* --- Viewer (Center) --- */
        #viewer-container { flex: 1; background: var(--viewer-bg); overflow: auto; padding: 40px; display: flex; flex-direction: column; align-items: center; gap: 30px; position: relative; }

        /* Page Wrapper Logic */
        .page-wrapper {
            position: relative;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }

        /* Stack Layers: Canvas(PDF) -> TextLayer(Selection) -> Canvas(Draw) */
        .pdf-canvas { display: block; }
        .textLayer { opacity: 1; mix-blend-mode: multiply; }
        .draw-canvas { position: absolute; top: 0; left: 0; cursor: crosshair; touch-action: none; pointer-events: none; z-index: 10; }
        .page-wrapper.draw-mode .draw-canvas { pointer-events: auto; }

        /* Page Controls (Floating) */
        .page-meta {
            position: absolute; top: 0; left: -50px; width: 40px; text-align: right;
            color: rgba(255,255,255,0.7); font-size: 14px; font-weight: bold;
        }
        .page-controls {
            position: absolute; top: 10px; right: -140px; width: 130px;
            display: flex; flex-direction: column; gap: 5px;
        }
        .add-btn {
            background: var(--primary); color: white; border: none; padding: 8px; border-radius: 4px;
            cursor: pointer; font-weight: 600; text-align: left; display: flex; align-items: center; gap: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: 0.2s;
        }
        .add-btn:hover { transform: translateX(-2px); }
        .add-btn.added { background: #10b981; }

        /* --- Sidebar (Right) --- */
        #sidebar { width: 320px; background: white; border-left: 1px solid var(--border); display: flex; flex-direction: column; z-index: 30; }
        .sidebar-header { padding: 15px; border-bottom: 1px solid var(--border); background: #f8fafc; }
        #basket-list { flex: 1; overflow-y: auto; padding: 10px; }

        .basket-item {
            background: white; border: 1px solid var(--border); border-radius: 6px; padding: 10px;
            margin-bottom: 8px; display: flex; align-items: center; gap: 10px; cursor: grab;
            position: relative; transition: border-color 0.2s;
        }
        .basket-item:hover { border-color: var(--primary); }
        .basket-item:active { cursor: grabbing; }
        .basket-thumb { width: 30px; height: 40px; background: #eee; border-radius: 2px; flex-shrink: 0; overflow: hidden; position: relative; }
        .basket-info { flex: 1; min-width: 0; }
        .doc-name { font-size: 11px; color: #64748b; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .page-num { font-weight: 600; font-size: 14px; }

        /* Hover Preview */
        #hover-preview {
            position: fixed; display: none; border: 2px solid var(--primary);
            background: white; box-shadow: 0 10px 25px rgba(0,0,0,0.3); z-index: 100; pointer-events: none;
        }

        /* Loading Overlay */
        #loader {
            position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(255,255,255,0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #e2e8f0; border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loader" style="display: none;">
    <div class="spinner"></div>
    <div id="loader-text" style="margin-top: 15px; color: #64748b; font-weight: 500;">Processing...</div>
</div>

<div id="hover-preview"></div>

<header>
    <div class="top-bar">
        <div class="logo">ProStitcher</div>
        <button class="btn" onclick="document.getElementById('file-input').click()"><b>+ Open PDFs</b></button>
        <input type="file" id="file-input" multiple accept=".pdf" style="display: none;">

        <div class="tabs-track" id="tabs-track"></div>

        <button class="btn" onclick="resetApp()" style="color: #ef4444; border-color: #fecaca;">Clear All</button>
    </div>

    <div class="toolbar">
        <div style="display: flex; align-items: center; gap: 5px;">
            <button class="btn" onclick="changeZoom(-0.2)">Ôºç</button>
            <span id="zoom-level" style="font-weight: 600; min-width: 45px; text-align: center;">100%</span>
            <button class="btn" onclick="changeZoom(0.2)">Ôºã</button>
        </div>

        <div style="width: 1px; height: 20px; background: #e2e8f0; margin: 0 10px;"></div>

        <button id="draw-toggle" class="btn" onclick="toggleDrawMode()">‚úé Draw Mode</button>
        <button class="btn" onclick="clearCurrentPageDraw()">Eraser (Page)</button>

        <div style="flex: 1;"></div>
        <span id="status-text" style="color: #64748b; font-size: 12px; font-style: italic;">Auto-saving...</span>
    </div>
</header>

<div class="workspace">
    <div id="viewer-container" onscroll="handleScroll()">
        <div id="empty-state" style="color: #ccc; text-align: center; margin-top: 15vh;">
            <div style="font-size: 40px; margin-bottom: 20px;">üìÑ</div>
            <h2>No Document Open</h2>
            <p>Open PDF files to begin stitching.</p>
        </div>
    </div>

    <div id="sidebar">
        <div class="sidebar-header">
            <h3 style="margin: 0 0 5px 0;">Export Queue</h3>
            <div style="display: flex; justify-content: space-between; font-size: 12px; color: #64748b; margin-bottom: 10px;">
                <span>Drag to reorder</span>
                <span id="queue-count">0 Pages</span>
            </div>
            <button class="btn-primary" id="download-btn" style="width: 100%; height: 40px;" disabled onclick="exportPDF()">
                Download Merged PDF
            </button>
        </div>
        <div id="basket-list"></div>
    </div>
</div>

<script>
    // --- Configuration & State ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    const STATE_KEY = 'pdf_stitcher_v2_state';
    const FILES_KEY = 'pdf_stitcher_v2_files';

    let state = {
        docs: [],         // { id, name, pageCount }
        selectedPages: [], // { id (unique), docId, pageNum, name }
        drawings: {},     // { "docId-pageNum": [ {x,y, type: 'path', points: []} ] }
        currentDocId: null,
        zoom: 1.0,
        drawMode: false,
        scrollTop: 0
    };

    let pdfFiles = {}; // { docId: ArrayBuffer } stored in IndexedDB
    let pdfJsDocs = {}; // Cache of loaded PDF.js documents
    let isDrawing = false;
    let currentPath = [];

    // --- Initialization & Persistence ---

    async function init() {
        showLoader('Loading Workspace...');
        try {
            // Setup Sidebar Sortable
            Sortable.create(document.getElementById('basket-list'), {
                animation: 150,
                ghostClass: 'blue-background-class',
                onEnd: (evt) => {
                    const item = state.selectedPages.splice(evt.oldIndex, 1)[0];
                    state.selectedPages.splice(evt.newIndex, 0, item);
                    saveState();
                }
            });

            // Setup Tabs Sortable
            Sortable.create(document.getElementById('tabs-track'), {
                animation: 150,
                onEnd: (evt) => {
                    const item = state.docs.splice(evt.oldIndex, 1)[0];
                    state.docs.splice(evt.newIndex, 0, item);
                    saveState();
                }
            });

            // Load Data
            const savedState = await localforage.getItem(STATE_KEY);
            if (savedState) state = { ...state, ...savedState }; // Merge defaults

            const savedFiles = await localforage.getItem(FILES_KEY);
            if (savedFiles) pdfFiles = savedFiles;

            // Hydrate PDF.js docs
            const promises = state.docs.map(async doc => {
                if (pdfFiles[doc.id]) {
                    const data = pdfFiles[doc.id];
                    pdfJsDocs[doc.id] = await pdfjsLib.getDocument({ data: data.slice(0) }).promise;
                }
            });
            await Promise.all(promises);

            renderTabs();
            renderBasket();

            // Restore visual state
            document.getElementById('zoom-level').innerText = Math.round(state.zoom * 100) + "%";
            toggleDrawMode(state.drawMode); // Restore draw button state

            if (state.currentDocId && pdfJsDocs[state.currentDocId]) {
                await renderViewer(state.currentDocId);
                // Restore scroll
                document.getElementById('viewer-container').scrollTop = state.scrollTop || 0;
            }

        } catch (e) {
            console.error("Init failed", e);
            alert("Could not restore previous session. Clearing data.");
            resetApp();
        } finally {
            hideLoader();
        }
    }

    async function saveState() {
        document.getElementById('status-text').innerText = 'Saving...';
        await localforage.setItem(STATE_KEY, state);
        await localforage.setItem(FILES_KEY, pdfFiles);
        document.getElementById('status-text').innerText = 'Saved';
        setTimeout(() => document.getElementById('status-text').innerText = '', 1000);
    }

    async function resetApp() {
        if(!confirm("Clear all PDFs and start over?")) return;
        await localforage.clear();
        location.reload();
    }

    // --- File Handling ---

    document.getElementById('file-input').onchange = async (e) => {
        showLoader('Processing PDFs...');
        const files = Array.from(e.target.files);

        for (const file of files) {
            const buffer = await file.arrayBuffer();
            const id = 'doc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            try {
                const pdfDoc = await pdfjsLib.getDocument({ data: buffer.slice(0) }).promise;

                // Store
                pdfFiles[id] = buffer;
                pdfJsDocs[id] = pdfDoc;

                state.docs.push({
                    id: id,
                    name: file.name,
                    pageCount: pdfDoc.numPages
                });
            } catch(err) {
                console.error("Error loading PDF", file.name, err);
                alert(`Error loading ${file.name}`);
            }
        }

        if (!state.currentDocId && state.docs.length > 0) {
            state.currentDocId = state.docs[state.docs.length - 1].id;
        } else if(state.docs.length > 0) {
            // Switch to the newly added one
             state.currentDocId = state.docs[state.docs.length - 1].id;
        }

        saveState();
        renderTabs();
        renderViewer(state.currentDocId);
        hideLoader();
    };

    // --- Tabs & Navigation ---

    function renderTabs() {
        const track = document.getElementById('tabs-track');
        track.innerHTML = '';
        state.docs.forEach(doc => {
            const el = document.createElement('div');
            el.className = `doc-tab ${doc.id === state.currentDocId ? 'active' : ''}`;
            el.innerHTML = `
                <span>${doc.name}</span>
                <div class="close-tab" onclick="event.stopPropagation(); closeDoc('${doc.id}')">‚úï</div>
            `;
            el.onclick = () => {
                state.currentDocId = doc.id;
                state.scrollTop = 0; // Reset scroll on tab switch
                saveState();
                renderTabs();
                renderViewer(doc.id);
            };
            track.appendChild(el);
        });
    }

    function closeDoc(id) {
        state.docs = state.docs.filter(d => d.id !== id);
        delete pdfFiles[id];
        delete pdfJsDocs[id];
        // Clean up selected pages from this doc
        state.selectedPages = state.selectedPages.filter(p => p.docId !== id);

        if (state.currentDocId === id) {
            state.currentDocId = state.docs.length ? state.docs[0].id : null;
        }
        saveState();
        renderTabs();
        renderBasket();
        renderViewer(state.currentDocId);
    }

    // --- Viewer & Rendering ---

    function changeZoom(delta) {
        state.zoom = Math.max(0.5, Math.min(3.0, state.zoom + delta));
        document.getElementById('zoom-level').innerText = Math.round(state.zoom * 100) + "%";
        saveState();
        renderViewer(state.currentDocId);
    }

    async function renderViewer(docId) {
        const container = document.getElementById('viewer-container');
        container.innerHTML = '';

        if (!docId || !pdfJsDocs[docId]) {
            container.innerHTML = document.getElementById('empty-state').outerHTML;
            document.getElementById('empty-state').style.display = 'block';
            return;
        }

        const pdfDoc = pdfJsDocs[docId];
        const docMeta = state.docs.find(d => d.id === docId);

        for (let i = 1; i <= pdfDoc.numPages; i++) {
            // Create DOM structure
            const wrapper = document.createElement('div');
            wrapper.className = `page-wrapper ${state.drawMode ? 'draw-mode' : ''}`;
            wrapper.dataset.pageNum = i;

            // Fetch viewport
            const page = await pdfDoc.getPage(i);
            const viewport = page.getViewport({ scale: state.zoom });

            wrapper.style.width = `${viewport.width}px`;
            wrapper.style.height = `${viewport.height}px`;

            // 1. PDF Canvas
            const canvas = document.createElement('canvas');
            canvas.className = 'pdf-canvas';
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            const ctx = canvas.getContext('2d');

            // 2. Text Layer
            const textLayerDiv = document.createElement('div');
            textLayerDiv.className = 'textLayer';
            textLayerDiv.style.width = `${viewport.width}px`;
            textLayerDiv.style.height = `${viewport.height}px`;
            textLayerDiv.style.position = 'absolute';
            textLayerDiv.style.top = '0';
            textLayerDiv.style.left = '0';

            // 3. Drawing Canvas
            const drawCanvas = document.createElement('canvas');
            drawCanvas.className = 'draw-canvas';
            drawCanvas.id = `draw-${docId}-${i}`;
            drawCanvas.width = viewport.width;
            drawCanvas.height = viewport.height;
            setupDrawingEvents(drawCanvas, docId, i, viewport.width / page.getViewport({scale:1}).width);

            // Controls
            const meta = document.createElement('div');
            meta.className = 'page-meta';
            meta.innerText = i;

            const controls = document.createElement('div');
            controls.className = 'page-controls';

            const isAdded = state.selectedPages.some(p => p.docId === docId && p.pageNum === i);
            const btn = document.createElement('button');
            btn.className = `add-btn ${isAdded ? 'added' : ''}`;
            btn.innerHTML = isAdded ? '‚úì Added' : '+ Add Page';
            btn.onclick = () => togglePageSelection(docId, i, docMeta.name, btn);

            controls.appendChild(btn);
            wrapper.appendChild(meta);
            wrapper.appendChild(canvas);
            wrapper.appendChild(textLayerDiv);
            wrapper.appendChild(drawCanvas);
            wrapper.appendChild(controls);
            container.appendChild(wrapper);

            // Async Render
            page.render({ canvasContext: ctx, viewport }).promise.then(() => {
                // Render Text
                page.getTextContent().then(textContent => {
                    pdfjsLib.renderTextLayer({
                        textContentSource: textContent,
                        container: textLayerDiv,
                        viewport: viewport,
                        textDivs: []
                    });
                });
                // Render existing drawings
                redrawCanvas(drawCanvas, docId, i);
            });
        }
    }

    function handleScroll() {
        if(state.currentDocId) {
            state.scrollTop = document.getElementById('viewer-container').scrollTop;
            // Debounce save? Skipping for now to avoid lag, saved on other actions
        }
    }

    // --- Selection Logic ---

    function togglePageSelection(docId, pageNum, docName, btnElement) {
        const existingIdx = state.selectedPages.findIndex(p => p.docId === docId && p.pageNum === pageNum);

        if (existingIdx > -1) {
            state.selectedPages.splice(existingIdx, 1);
            btnElement.classList.remove('added');
            btnElement.innerText = '+ Add Page';
        } else {
            state.selectedPages.push({
                id: Date.now() + Math.random(),
                docId,
                pageNum,
                name: docName
            });
            btnElement.classList.add('added');
            btnElement.innerText = '‚úì Added';
        }
        saveState();
        renderBasket();
    }

    function renderBasket() {
        const list = document.getElementById('basket-list');
        list.innerHTML = '';
        document.getElementById('queue-count').innerText = `${state.selectedPages.length} Pages`;
        document.getElementById('download-btn').disabled = state.selectedPages.length === 0;

        state.selectedPages.forEach((item, index) => {
            const el = document.createElement('div');
            el.className = 'basket-item';

            // Hover events
            el.onmouseenter = (e) => showHoverPreview(e, item);
            el.onmouseleave = hideHoverPreview;

            el.innerHTML = `
                <div class="basket-thumb">
                    </div>
                <div class="basket-info">
                    <div class="page-num">Page ${item.pageNum}</div>
                    <div class="doc-name">${item.name}</div>
                </div>
                <button style="border:none; background:none; cursor:pointer; color:#94a3b8;" onclick="removePage(${index})">‚úï</button>
            `;
            list.appendChild(el);
        });
    }

    function removePage(index) {
        const item = state.selectedPages[index];
        state.selectedPages.splice(index, 1);
        saveState();
        renderBasket();
        // If current viewer shows this page, update button
        if (state.currentDocId === item.docId) {
            renderViewer(state.currentDocId);
        }
    }

    // --- Hover Preview ---
    async function showHoverPreview(e, item) {
        const preview = document.getElementById('hover-preview');
        preview.style.display = 'block';
        preview.style.left = (e.clientX + 20) + 'px';
        preview.style.top = Math.min(e.clientY - 50, window.innerHeight - 300) + 'px'; // Prevent going offscreen
        preview.innerHTML = '<div style="padding:10px; font-size:12px;">Loading...</div>';

        if(pdfJsDocs[item.docId]) {
            const page = await pdfJsDocs[item.docId].getPage(item.pageNum);
            const viewport = page.getViewport({ scale: 0.3 }); // Small scale
            const canvas = document.createElement('canvas');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;

            preview.innerHTML = '';
            preview.appendChild(canvas);
        }
    }

    function hideHoverPreview() {
        document.getElementById('hover-preview').style.display = 'none';
    }

    // --- Drawing & Annotation ---

    function toggleDrawMode(forceVal) {
        if (typeof forceVal !== 'undefined') state.drawMode = forceVal;
        else state.drawMode = !state.drawMode;

        const btn = document.getElementById('draw-toggle');
        const wrappers = document.querySelectorAll('.page-wrapper');

        if (state.drawMode) {
            btn.classList.add('active');
            wrappers.forEach(w => w.classList.add('draw-mode'));
        } else {
            btn.classList.remove('active');
            wrappers.forEach(w => w.classList.remove('draw-mode'));
        }
        saveState();
    }

    function setupDrawingEvents(canvas, docId, pageNum, scaleFactor) {
        const key = `${docId}-${pageNum}`;
        const ctx = canvas.getContext('2d');
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.strokeStyle = '#ef4444'; // Red pen

        const getPos = (e) => {
            const rect = canvas.getBoundingClientRect();
            // Handle touch or mouse
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: (clientX - rect.left),
                y: (clientY - rect.top)
            };
        };

        const start = (e) => {
            if (!state.drawMode) return;
            if (e.type === 'mousedown' && e.button !== 0) return; // Only left click
            e.preventDefault();
            isDrawing = true;
            const pos = getPos(e);
            currentPath = [{ x: pos.x, y: pos.y }];
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
        };

        const move = (e) => {
            if (!isDrawing || !state.drawMode) return;
            e.preventDefault();
            const pos = getPos(e);
            currentPath.push({ x: pos.x, y: pos.y });
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        };

        const end = (e) => {
            if (!isDrawing) return;
            isDrawing = false;
            ctx.closePath();

            // Save path
            if (!state.drawings[key]) state.drawings[key] = [];
            // We store raw canvas coordinates relative to the current Zoom.
            // In a real app we must normalize to PDF point coordinates (1/72 inch).
            // For this single file, we save normalized 0-1 coords to support resizing.
            const w = canvas.width;
            const h = canvas.height;
            const normalizedPath = currentPath.map(p => ({ x: p.x/w, y: p.y/h }));

            state.drawings[key].push({ points: normalizedPath });
            saveState();
        };

        canvas.addEventListener('mousedown', start);
        canvas.addEventListener('mousemove', move);
        canvas.addEventListener('mouseup', end);
        canvas.addEventListener('mouseout', end);
        // Touch support
        canvas.addEventListener('touchstart', start);
        canvas.addEventListener('touchmove', move);
        canvas.addEventListener('touchend', end);
    }

    function redrawCanvas(canvas, docId, pageNum) {
        const key = `${docId}-${pageNum}`;
        const paths = state.drawings[key];
        if (!paths) return;

        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;

        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.strokeStyle = '#ef4444';

        paths.forEach(pathData => {
            const points = pathData.points;
            if(points.length < 1) return;
            ctx.beginPath();
            ctx.moveTo(points[0].x * w, points[0].y * h);
            for(let i=1; i<points.length; i++) {
                ctx.lineTo(points[i].x * w, points[i].y * h);
            }
            ctx.stroke();
        });
    }

    function clearCurrentPageDraw() {
        if (!state.currentDocId) return;
        // Find visible page? or just clear the first one?
        // Let's implement a "click button, then click page to clear" or just clear all on current doc?
        // Simpler: Ask user.
        if(confirm("Clear drawings on ALL pages of this document?")) {
            // Remove keys starting with currentDocId
             Object.keys(state.drawings).forEach(k => {
                 if(k.startsWith(state.currentDocId)) delete state.drawings[k];
             });
             saveState();
             renderViewer(state.currentDocId);
        }
    }

    // --- Export Logic (The Heavy Lifting) ---

    async function exportPDF() {
        const btn = document.getElementById('download-btn');
        btn.disabled = true;
        btn.innerText = "Generating...";
        showLoader("Stitching and burning drawings...");

        try {
            const mergedPdf = await PDFLib.PDFDocument.create();

            for (const item of state.selectedPages) {
                // 1. Load Source
                const srcBytes = pdfFiles[item.docId];
                const srcDoc = await PDFLib.PDFDocument.load(srcBytes);

                // 2. Copy Page
                const [copiedPage] = await mergedPdf.copyPages(srcDoc, [item.pageNum - 1]);
                const embeddedPage = mergedPdf.addPage(copiedPage);

                // 3. Handle Drawings
                const drawKey = `${item.docId}-${item.pageNum}`;
                if (state.drawings[drawKey] && state.drawings[drawKey].length > 0) {
                    // To burn drawings, we need to generate a transparent PNG of the drawing
                    // We can use a temporary canvas for this
                    const { width, height } = embeddedPage.getSize();

                    const tempCanvas = document.createElement('canvas');
                    // Render high res for quality
                    const scale = 2;
                    tempCanvas.width = width * scale;
                    tempCanvas.height = height * scale;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.scale(scale, scale);

                    // Draw paths
                    ctx.lineWidth = 2;
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.strokeStyle = '#ef4444';

                    state.drawings[drawKey].forEach(pathData => {
                         const points = pathData.points;
                         if(points.length < 1) return;
                         ctx.beginPath();
                         ctx.moveTo(points[0].x * width, points[0].y * height);
                         for(let i=1; i<points.length; i++) {
                             ctx.lineTo(points[i].x * width, points[i].y * height);
                         }
                         ctx.stroke();
                    });

                    // Convert to PNG blob
                    const pngUrl = tempCanvas.toDataURL('image/png');
                    const pngImageBytes = await fetch(pngUrl).then(res => res.arrayBuffer());
                    const embeddedImage = await mergedPdf.embedPng(pngImageBytes);

                    // Draw image on top of page
                    embeddedPage.drawImage(embeddedImage, {
                        x: 0,
                        y: 0,
                        width: width,
                        height: height,
                    });
                }
            }

            const pdfBytes = await mergedPdf.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = "stitched_pro.pdf";
            a.click();

        } catch (e) {
            console.error(e);
            alert("Export failed: " + e.message);
        } finally {
            hideLoader();
            btn.disabled = false;
            btn.innerText = "Download Merged PDF";
        }
    }

    function showLoader(text) {
        document.getElementById('loader').style.display = 'flex';
        document.getElementById('loader-text').innerText = text;
    }
    function hideLoader() {
        document.getElementById('loader').style.display = 'none';
    }

    // Start
    init();

</script>
</body>
</html>
